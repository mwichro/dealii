// ------------------------------------------------------------------------
//
// SPDX-License-Identifier: LGPL-2.1-or-later
// Copyright (C) 2025 by the deal.II authors
//
// This file is part of the deal.II library.
//
// Part of the source code is dual licensed under Apache-2.0 WITH
// LLVM-exception OR LGPL-2.1-or-later. Detailed license information
// governing the source code and code contributions can be found in
// LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.
//
// ------------------------------------------------------------------------

#ifndef dealii_segment_data_out_h
#define dealii_segment_data_out_h

#include <deal.II/base/config.h>

#include <deal.II/base/data_out_base.h>
#include <deal.II/base/geometry_info.h>
#include <deal.II/base/iterator_range.h>
#include <deal.II/base/point.h>

#include <deal.II/boost_adaptors/point.h>
#include <deal.II/boost_adaptors/segment.h>

#include <boost/geometry/index/rtree.hpp>
#include <boost/geometry/strategies/strategies.hpp>


DEAL_II_NAMESPACE_OPEN

/**
 * This class generates graphical output for line segment objects, starting from
 * any object that can be converted by boost to a Segment.
 *
 * Line segments are one-dimensional objects embedded in a @p dim dimensional
 * space. This class creates output data that can be visualized as lines in
 * visualization tools.
 */
template <int dim>
class SegmentDataOut : public DataOutInterface<1, dim>
{
public:
  /**
   * Constructor.
   */
  SegmentDataOut() = default;

  /**
   * Destructor.
   */
  ~SegmentDataOut() = default;

  /**
   * Generate patches from a range of objects that can be converted by boost to
   * a collection of Segment objects.
   *
   * You could pass to this function iterators to Segment objects, or to
   * pairs or tuples in which the first element is a Segment object, or to
   * std::pair<Point<dim>, Point<dim>> objects representing line segments.
   */
  template <class ConvertibleToSegmentIterator>
  void
  build_patches(const ConvertibleToSegmentIterator &begin,
                const ConvertibleToSegmentIterator &end);

  /**
   * Generate patches from a container of objects that can be converted by boost
   * to a collection of Segment objects.
   *
   * You could pass to this function a container of Segment objects, or a
   * container of pairs or tuples in which the first element is a Segment
   * object, or a container of std::pair<Point<dim>, Point<dim>> objects
   * representing line segments.
   */
  template <class Container>
  void
  build_patches(const Container &segments);

  /**
   * Attach data to each output patch that was generated by build_patches().
   *
   * The @p datasets parameter is expected to have the same size of the
   * container you used in the call to build_patches(), and each entry should
   * have the same size of the @p dataset_names argument.
   *
   * @param[in] datasets The actual data to attach to each patch
   * @param[in] dataset_names The name of each component of the dataset
   */
  void
  add_datasets(const std::vector<std::vector<double>> &datasets,
               const std::vector<std::string>         &dataset_names);

protected:
  // Copy doc
  virtual const std::vector<dealii::DataOutBase::Patch<1, dim>> &
  get_patches() const override;

  // Copy doc
  virtual std::vector<std::string>
  get_dataset_names() const override;

private:
  /**
   * The actual segments as patches.
   */
  std::vector<DataOutBase::Patch<1, dim>> patches;

  /**
   * Names of datasets.
   */
  std::vector<std::string> dataset_names;
};


// Template and inline functions
#ifndef DOXYGEN
template <int dim>
template <class ConvertibleToSegmentIterator>
void
SegmentDataOut<dim>::build_patches(
  const ConvertibleToSegmentIterator &begin,
  const ConvertibleToSegmentIterator &end)
{
  const unsigned int N = std::distance(begin, end);

  dataset_names.clear();
  patches.resize(N);

  unsigned int i = 0;
  for (const auto &value :
       IteratorRange<ConvertibleToSegmentIterator>(begin, end))
    {
      // Convert to Segment<dim> which is compatible with std::pair<Point<dim>, Point<dim>>
      Segment<dim> segment;
      boost::geometry::convert(*value, segment);
      
      // A line segment has 2 vertices
      patches[i].vertices[0]    = segment.first;
      patches[i].vertices[1]    = segment.second;
      patches[i].patch_index    = i;
      patches[i].n_subdivisions = 1;
      patches[i].reference_cell = ReferenceCells::get_hypercube<1>();
      patches[i].points_are_available = false;
      
      ++i;
    }
}



template <int dim>
template <class Container>
void
SegmentDataOut<dim>::build_patches(const Container &segments)
{
  build_patches(segments.begin(), segments.end());
}



template <int dim>
void
SegmentDataOut<dim>::add_datasets(
  const std::vector<std::vector<double>> &datasets,
  const std::vector<std::string>         &names)
{
  AssertDimension(datasets.size(), patches.size());
  dataset_names = names;
  for (unsigned int i = 0; i < datasets.size(); ++i)
    {
      AssertDimension(datasets[i].size(), names.size());
      // For line segments, we have 2 vertices (start and end points)
      patches[i].data.reinit(names.size(), 2);
      for (unsigned int j = 0; j < names.size(); ++j)
        for (unsigned int k = 0; k < 2; ++k)
          patches[i].data(j, k) = datasets[i][j];
    }
}



template <int dim>
const std::vector<DataOutBase::Patch<1, dim>> &
SegmentDataOut<dim>::get_patches() const
{
  return patches;
}



template <int dim>
std::vector<std::string>
SegmentDataOut<dim>::get_dataset_names() const
{
  return dataset_names;
}

#endif

DEAL_II_NAMESPACE_CLOSE

#endif
